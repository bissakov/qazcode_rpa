{"id":"rpa-0mt","title":"Persist Global Settings to Config File","description":"Implement persistent global application settings storage.\n\nCurrently, AppSettings (font_size, show_minimap, allow_node_resize, language, current_max_entry_size) are in-memory only and reset on app close. This task adds configuration file persistence.\n\n## Requirements\n\n1. **Config File System**\n   - Use dirs::config_dir() for platform-specific config location\n   - Store settings in {config_dir}/rpa-studio/settings.json\n   - Auto-create config directory if missing\n\n2. **Settings Serialization**\n   - Serialize AppSettings struct to JSON\n   - Implement load_settings() function (returns AppSettings, fallback to defaults if missing)\n   - Implement save_settings() function (called after settings dialog Apply)\n\n3. **Integration Points**\n   - Load settings during app initialization (before UI rendering)\n   - Save settings when user clicks Apply in Settings dialog (main.rs line 515)\n   - Update font size and locale on load (currently done at startup)\n\n4. **Error Handling**\n   - Log config file errors to console (not execution panel)\n   - Gracefully fallback to default AppSettings if config is corrupted\n\n## Files to Modify\n- crates/rpa-studio/src/main.rs (AppSettings struct, initialization, settings dialog)\n- Cargo.toml (add dirs crate dependency if needed)\n\n## Notes\n- This task is a prerequisite for 'Open Last Project on Startup' feature\n- Keep settings global (not per-project)\n- All strings use i18n t!() macro","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-25T17:54:23.0053123+05:00","updated_at":"2025-12-25T17:54:29.3461273+05:00"}
{"id":"rpa-1co","title":"Add Undo/Redo buttons to menu bar","description":"Add Undo/Redo buttons next to the Run button in the toolbar\n\n## Problem\nUsers need visual buttons and keyboard hints for undo/redo operations.\n\n## Instructions\n1. In crates/rpa-studio/src/main.rs, find render_menu_bar() method\n2. Locate the Run button (▶ Run)\n3. Add two buttons after it:\n   - Button: \"⟲ Undo (Ctrl+Z)\" - enabled when has_undo() == true\n   - Button: \"⟳ Redo (Ctrl+Y)\" - enabled when has_redo() == true\n\n4. When clicked, call self.undo() and self.redo() methods (stub for now)\n\n5. Use ui.add_enabled() for disabled state (grayed out)\n\n## Suggested Implementation\n","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-27T12:49:01.9595225+05:00","updated_at":"2025-12-27T12:57:16.7961826+05:00","closed_at":"2025-12-27T12:57:16.7961826+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-1co","depends_on_id":"rpa-bgl","type":"blocks","created_at":"2025-12-27T12:49:52.4911606+05:00","created_by":"daemon"}]}
{"id":"rpa-1p7","title":"Add allow-attributes reason clauses to #[allow] attributes","description":"Add reason clauses to #[allow] attributes: (1) activity_metadata.rs:157 - add reason to 'allow(clippy::type_complexity)', (2) ir.rs:142 - add reason to 'allow(dead_code)'. Pattern: #[allow(lint, reason = \"explanation\")]","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T16:02:59.5347425+05:00","updated_at":"2025-12-25T16:13:05.8793816+05:00"}
{"id":"rpa-258","title":"Fix default_trait_access (use Self::default())","description":"Fix default_trait_access by using Self::default() instead of Default::default() where applicable","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T16:00:07.1268172+05:00","updated_at":"2025-12-25T16:11:54.1410025+05:00"}
{"id":"rpa-2v5","title":"Implement flattened multi-scenario IR with call stack","description":"# Flattened Multi-Scenario IR with Call Stack\n\n## Architecture Overview\n\nImplement a **multi-scenario IR compilation system** that:\n- Flattens all reachable scenarios into a single linear instruction stream\n- Uses a runtime call stack for nested scenario execution (not inlining)\n- Pre-allocates all variables for reachable scenarios before execution begins\n- Supports parameter passing with In/Out/InOut semantics\n- Enforces complete variable isolation per call frame\n- Validates all variable names globally — no shadowing allowed (compile-time error)\n- Detects recursion at compile-time and warns, but allows it with runtime depth guard (max 100)\n\n## Critical Design Points\n\n### Variable Model (Preserved)\n- **All variables pre-allocated at IR compile-time** via `variables.id(name)`\n- UI receives complete variable list **before execution starts**\n- Only `VarEvent::SetId` events during execution (no surprises)\n- **Zero variable creation during execution** — all must exist at compile-time\n\n### Parameter Passing Semantics\n- **In**: Copy value in → param_var (isolated, not visible to caller after)\n- **Out**: Start undefined → param_var gets initial value during call → copy back to source_var\n- **InOut**: Copy value in → param_var → copy back to source_var\n\n### Variable Scoping Rule (Complete Isolation)\n- Scenario can only access variables it receives as In/Out/InOut parameters\n- All other variables are local to that scenario\n- Parent cannot see child's local variables\n- Requires explicit parameter passing for all cross-scenario variable access\n\n### Variable Shadowing Validation\n- If Scenario A defines variable \"x\" and Scenario B also tries to define \"x\" → **COMPILE-TIME ERROR**\n- All variable names must be unique across entire reachable program\n- Prevents confusion and accidental aliasing\n\n### Recursion Handling\n- Compile-time: Detect cycles in call graph → **warn but allow**\n- Runtime: Max call depth guard (100) → **error if exceeded**\n- Allows valid recursive scenarios while preventing infinite loops\n\n### Try/Catch Across Boundaries\n- Error propagates up call stack, caught at nearest handler\n- Standard exception semantics\n\n## Data Structure Changes\n\n### Activity::CallScenario (node_graph.rs:592-594)\n```rust\n// Current\nCallScenario {\n    scenario_id: Uuid,\n}\n\n// New\nCallScenario {\n    scenario_id: Uuid,\n    parameters: Vec\u003cParameterBinding\u003e,  // NEW\n}\n```\n\n### New Enums/Structs to Add (node_graph.rs after Activity enum)\n```rust\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]\npub enum ParameterDirection {\n    In,      // Copy value in, discard on return\n    Out,     // No copy in, copy value out on return\n    InOut,   // Copy value in, copy value out on return\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ParameterBinding {\n    pub param_var_id: VarId,        // Variable ID in called scenario\n    pub source_var_id: VarId,       // Variable ID in caller scenario\n    pub direction: ParameterDirection,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ScenarioParameter {\n    pub var_id: VarId,\n    pub var_name: String,\n    pub direction: ParameterDirection,\n}\n```\n\n### Extended Scenario Struct (node_graph.rs:265-270)\n```rust\npub struct Scenario {\n    pub id: Uuid,\n    pub name: String,\n    pub nodes: Vec\u003cNode\u003e,\n    pub connections: Vec\u003cConnection\u003e,\n    pub parameters: Vec\u003cScenarioParameter\u003e,  // NEW: Parameter definitions\n}\n```\n\n### Extended IrProgram Struct (ir.rs:88-93)\n```rust\npub struct IrProgram {\n    pub instructions: Vec\u003cInstruction\u003e,\n    pub entry_point: usize,\n    pub scenario_start_index: HashMap\u003cUuid, usize\u003e,      // NEW: Maps scenario ID → instruction index\n    pub scenario_call_graph: HashMap\u003cUuid, HashSet\u003cUuid\u003e\u003e,  // NEW: Maps scenario ID → reachable scenarios\n    pub recursive_scenarios: HashSet\u003cUuid\u003e,              // NEW: Set of recursive scenario IDs\n}\n```\n\n### Instruction Enum Addition (ir.rs:12-86)\n```rust\n// Extend existing enum with:\nCallScenario {\n    scenario_id: Uuid,\n    parameters: Vec\u003cParameterBinding\u003e,  // NEW: Parameter bindings\n}\n```\n\n### Extended IrBuilder Struct (ir.rs:140-150)\n```rust\npub struct IrBuilder\u003c'a\u003e {\n    project: \u0026'a Project,  // Changed from: scenario: \u0026'a Scenario\n    program: IrProgram,\n    \n    // NEW: Cross-scenario reachability tracking\n    scenario_reachable_nodes: HashMap\u003cUuid, HashSet\u003cUuid\u003e\u003e,\n    compiled_scenarios: HashSet\u003cUuid\u003e,\n    compiled_nodes: HashSet\u003c(Uuid, Uuid)\u003e,  // (scenario_id, node_id)\n    node_start_index: HashMap\u003c(Uuid, Uuid), usize\u003e,\n    scenario_start_indices: HashMap\u003cUuid, usize\u003e,\n    \n    // Existing\n    variables: \u0026'a mut Variables,\n    \n    // NEW: Call graph for recursion detection\n    call_graph: HashMap\u003cUuid, HashSet\u003cUuid\u003e\u003e,\n}\n```\n\n### Call Stack in IrExecutor (execution.rs:22-30)\n```rust\npub struct CallFrame {\n    scenario_id: Uuid,\n    return_address: usize,\n    parameter_bindings: Vec\u003cParameterBinding\u003e,\n    var_snapshot: Vec\u003cVarId\u003e,  // Optional: save local var state\n}\n\npub struct IrExecutor\u003c'a, L: LogOutput\u003e {\n    program: \u0026'a IrProgram,\n    project: \u0026'a Project,\n    context: \u0026'a mut ExecutionContext,\n    log: \u0026'a mut L,\n    error_handlers: Vec\u003cusize\u003e,\n    iteration_counts: HashMap\u003cusize, usize\u003e,\n    \n    call_stack: Vec\u003cCallFrame\u003e,              // NEW: Call stack for nested scenarios\n    current_scenario_id: Uuid,               // NEW: Track current scenario context\n}\n```\n\n## Compilation Pipeline (4 Phases)\n\n### Phase 1: Cross-Scenario Reachability Analysis\n- Start from `main_scenario` Start node\n- Follow `CallScenario` edges (DFS)\n- Build: `scenario_reachable_nodes` (nodes reachable within each scenario)\n- Build: `call_graph` (scenario → scenarios it calls)\n- Detect cycles → warn but allow compilation\n\n**Files affected:**\n- `crates/rpa-core/src/validation.rs` (ScenarioValidator, lines ~400-500)\n- Add new function: `compute_call_graph() -\u003e HashMap\u003cUuid, HashSet\u003cUuid\u003e\u003e`\n- Add new function: `detect_recursive_scenarios() -\u003e HashSet\u003cUuid\u003e`\n\n### Phase 2: Variable Allocation \u0026 Validation\nFor each reachable scenario:\n- Register all variables from SetVariable activities\n- Register all variables from Loop index parameters\n- Register all formal parameters from CallScenario bindings\n- Call `variables.id(name)` to pre-allocate VarIds\n\n**Validate:**\n- No duplicate variable names across all reachable scenarios → error if found\n- All referenced variables exist\n\n**Files affected:**\n- `crates/rpa-core/src/ir.rs` (IrBuilder::build, lines 273-286)\n- Add new method: `fn allocate_variables_for_reachable_scenarios() -\u003e Result\u003c(), String\u003e`\n- Add new method: `fn validate_variable_uniqueness() -\u003e Result\u003c(), String\u003e`\n\n### Phase 3: IR Instruction Generation (Single Pass)\n- Traverse reachable scenarios as single DFS tree from main Start node\n- Generate single linear instruction stream\n- Record `scenario_start_index` for each scenario\n- When `CallScenario` reached: embed parameter bindings in instruction\n\n**Files affected:**\n- `crates/rpa-core/src/ir.rs` (IrBuilder methods, lines 273-656)\n- Refactor: `fn compile_from_node() -\u003e Result\u003c(), String\u003e` to track (scenario_id, node_id) instead of just node_id\n- Add new method: `fn compile_scenario_in_flattened_context() -\u003e Result\u003c(), String\u003e`\n\n### Phase 4: Recursion Detection \u0026 Warning\n- Analyze `call_graph` for cycles (DFS-based cycle detection)\n- For each cycle found: log warning to validation results\n- Still allow compilation and execution\n- Runtime guard: max call depth = 100 (in executor)\n\n**Files affected:**\n- `crates/rpa-core/src/validation.rs` (ScenarioValidator, lines ~400-500)\n- `crates/rpa-core/src/ir.rs` (IrBuilder::build, after Phase 3 compilation)\n\n## Execution Pipeline\n\n### When Instruction::CallScenario is executed (execution.rs, new handler ~496-545)\n1. Check call depth \u003c 100 → error if exceeded\n2. Parameter copy-in (In/InOut directions):\n   - For each binding: copy `source_var` value → `param_var`\n   - Send `VarEvent::SetId` to UI for each parameter\n3. Push call frame to stack:\n   - Store: scenario_id, return_address (pc + 1), parameter_bindings\n4. Update current_scenario_id\n5. Log \"Entering scenario: {name}\"\n6. Jump to `scenario_start_index[scena\n","acceptance_criteria":"\n✓ Multi-scenario reachability analysis implemented (Phase 1)\n✓ Variable allocation and uniqueness validation working (Phase 2)\n✓ Single-pass flattened IR compilation complete (Phase 3)\n✓ Recursion detection with warnings operational (Phase 4)\n✓ Call stack execution with In/Out/InOut parameter passing working\n✓ All variables pre-allocated before execution (UI visibility)\n✓ Complete variable isolation per call frame enforced\n✓ No variable shadowing allowed (compile-time error)\n✓ Runtime recursion depth guard (max 100) functional\n✓ Existing projects still work (empty parameters = no isolation)\n","status":"in_progress","priority":0,"issue_type":"feature","created_at":"2025-12-26T14:05:42.1842209+05:00","updated_at":"2025-12-27T00:04:11.6385033+05:00"}
{"id":"rpa-2v8","title":"Crash when undoing scenario deletion with stale scenario index","description":"## Problem\nApp crashes with 'index out of bounds' panic when undoing the deletion of a scenario. The crash occurs in get_current_scenario() at line 1369 when trying to access scenarios[i] where the vector is empty (len=0 but index=1).\n\nStack trace shows:\n- Thread panics at crates/rpa-studio/src/main.rs:1369:47\n- core::panicking::panic_bounds_check triggered\n- get_current_scenario() called from render_canvas_panel()\n\n## Root Cause\nWhen a scenario is deleted:\n1. The scenario is removed from the vector\n2. current_scenario_index is reset to None or adjusted (line 1104-1110)\n3. User presses Ctrl+Z to undo\n4. undo() restores the project state from history (scenario is re-added)\n5. BUT current_scenario_index is NOT validated after restoration\n6. If current_scenario_index still points to a now-invalid index, the next render crashes\n\nThe undo() and redo() methods clear transient UI state but don't validate that current_scenario_index still refers to a valid scenario.\n\n## Solution\nIn both undo() and redo() methods, after restoring project state:\n1. Validate that current_scenario_index is within bounds\n2. If Some(i) where i \u003e= project.scenarios.len(), reset to None (main scenario)\n3. This ensures UI state consistency with restored project state\n\nImplementation:\n- Add validation in undo() method after project restoration\n- Add identical validation in redo() method after project restoration\n- Use: if let Some(idx) = self.current_scenario_index \u0026\u0026 idx \u003e= self.project.scenarios.len() { self.current_scenario_index = None; }","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-27T13:31:20.9900424+05:00","updated_at":"2025-12-27T13:32:25.9240426+05:00","closed_at":"2025-12-27T13:32:25.9240426+05:00","close_reason":"Closed"}
{"id":"rpa-3cd","title":"Implement activity drag-and-drop to canvas with ghost preview","description":"## Problem\nCurrently, activities can only be added to the canvas by clicking a button in the left sidebar, which always places the new node at the viewport center with a fixed offset. Users cannot precisely position nodes where they want them or use an intuitive drag-and-drop workflow.\n\n## Instruction\nImplement drag-and-drop functionality for activities from the sidepanel to the canvas:\n\n1. **Click behavior (preserve current)**: Click activity button → node appears at viewport center\n2. **Drag behavior (new)**: Drag activity button to canvas → ghost preview follows cursor → node placed at drop position\n3. **Drag outside canvas**: Release outside canvas → no node created (action cancelled)\n4. **Visual feedback**: \n   - Semi-transparent ghost node preview while dragging over canvas\n   - Cursor icon: Grab (over canvas), NoDrop (outside)\n5. **CallScenario handling**: Show warning both on click AND drag attempt if no scenarios exist\n6. **Auto-connect**: Preserve existing auto-connection logic when dropped node hovers over existing connections\n\n## Solution\nModify two files with ~95 lines of code:\n\n### File 1: crates/rpa-studio/src/main.rs\n\n**1. Add state fields to RpaApp struct (lines 101-120):**\n- dragging_activity: Option\u003cActivity\u003e\n- drag_start_pos: Option\u003cegui::Pos2\u003e\n- is_over_canvas: bool\n\n**2. Update RpaApp::default() (lines 122-145):**\n- Initialize new fields to None/false\n\n**3. Refactor render_activity_buttons() (lines 965-1018):**\n- Capture button_response instead of just checking clicked()\n- Add drag_started() branch to set dragging_activity\n- Show warning for CallScenario with no scenarios on both click and drag\n- Keep existing viewport-center logic for clicked()\n\n**4. Update render_canvas_panel() (lines 206-237):**\n- Add call to handle_activity_drag_drop() after canvas rendering\n\n**5. Add handle_activity_drag_drop() method:**\n- Check if pointer is over canvas rect\n- Set cursor icon (Grab/NoDrop) based on position\n- Call draw_ghost_node_preview() while hovering\n- On mouse release: create node if over canvas, reset state\n- Automatically cancel if released outside canvas\n\n**6. Add draw_ghost_node_preview() method:**\n- Create temporary Node with preview activity\n- Transform world coords to screen coords using existing pan/zoom\n- Use ui::draw_node_transformed() to render preview\n- Add semi-transparent black overlay (50% alpha)\n\n**7. Add import:**\n- use egui::Color32; (if not already present)\n\n### File 2: crates/rpa-studio/src/ui.rs\n\n**1. Change visibility of draw_node_transformed() (line 1213):**\n- Change: fn draw_node_transformed\u003cF\u003e(...) \n- To: pub fn draw_node_transformed\u003cF\u003e(...)\n\n## Technical Details\n\n**Architecture:**\n- Drag state isolated in RpaApp; no conflicts with knife tool, connections, or resize handles\n- Ghost preview uses egui::LayerId::Tooltip layer for proper depth\n- Coordinate transforms reuse existing pan/zoom system\n- Activity cloning used (already implemented)\n- Leverages existing add_node() method for auto-connect preservation\n\n**Testing:**\n- Click: node at viewport center with offset (existing behavior)\n- Drag over canvas: ghost follows, cursor Grab\n- Drag outside canvas: cursor NoDrop\n- Release on canvas: node created at drop position\n- Release outside: no node created\n- CallScenario warning on both click and drag attempts\n- Auto-connect works with dropped nodes\n- Works across all activity categories and zoom/pan levels","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-26T22:33:56.1691753+05:00","updated_at":"2025-12-26T22:38:33.5539661+05:00","closed_at":"2025-12-26T22:38:33.5539661+05:00","close_reason":"Closed"}
{"id":"rpa-3pg","title":"Use let...else pattern where applicable","description":"Use let...else pattern where applicable. Affects: evaluator.rs lines 176-179 where match on Option is used for current()","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T16:00:00.6316555+05:00","updated_at":"2025-12-25T21:27:37.2786783+05:00","closed_at":"2025-12-25T21:27:37.2786783+05:00","close_reason":"Closed"}
{"id":"rpa-42n","title":"Add #[non_exhaustive] to exported enums and structs","description":"Add #[non_exhaustive] attribute to exported enums and structs in activity_metadata.rs: ActivityCategory (line 6), ColorCategory (line 15), PropertyType (line 31), PinConfig (line 25), PropertyDef (line 41), ActivityMetadata (line 47)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T16:03:01.935582+05:00","updated_at":"2025-12-25T21:38:30.0929001+05:00","closed_at":"2025-12-25T21:38:30.0929001+05:00","close_reason":"Closed"}
{"id":"rpa-455","title":"Implement drag transaction grouping for nodes","description":"Group node drag operations so one drag = one undo step (not per-frame)\n\n## Problem\nIf each frame during a drag operation created an undo snapshot, the history would be polluted with hundreds of position changes. Need to group entire drag as single undo step.\n\n## Instructions\n1. Find node drag handling in ui::render_node_graph() or main.rs canvas handling\n2. When drag starts (mouse down on node):\n   - Call: self.begin_undo_transaction()\n   - Store initial position\n\n3. During drag (mouse moving):\n   - Update position, but DON'T snapshot\n   - Keep transaction_in_progress = true\n\n4. When drag ends (mouse up):\n   - Call: self.end_undo_transaction()\n   - This takes single snapshot of final position\n\n## Suggested Implementation\nAdd transaction state tracking:\n- transaction_in_progress: bool in RpaApp\n- In drag handler: set true at start, false at end\n- Only call feed_state() on transaction end","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-27T12:49:17.7570152+05:00","updated_at":"2025-12-27T13:10:12.5364019+05:00","closed_at":"2025-12-27T13:10:12.5364019+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-455","depends_on_id":"rpa-oc9","type":"blocks","created_at":"2025-12-27T12:49:54.3299119+05:00","created_by":"daemon"}]}
{"id":"rpa-4jv","title":"Fix unneeded field patterns (use .. syntax)","description":"Fix unneeded field patterns. Replace wildcard patterns with .. syntax: (1) execution.rs:367 - change 'index: _' to use '..', (2) execution.rs:533 - change 'code: _' to use '..' in RunPowershell pattern, (3) validation.rs:638 - change 'level: _' to use '..' in Log pattern","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T16:02:57.1846289+05:00","updated_at":"2025-12-25T16:13:03.6442089+05:00"}
{"id":"rpa-4r9","title":"Implement TryCatch node compilation in nested scenarios","description":"PROBLEM:\nTryCatch nodes in nested scenarios fall through to the default handler and are not compiled. The compile_from_called_scenario() function doesn't handle Activity::TryCatch, causing try-catch error handling to never work in called scenarios.\n\nLocation: ir.rs lines 731-821 (missing Activity::TryCatch handler)\n\nSOLUTION:\nAdd TryCatch node handling to compile_from_called_scenario():\n1. Add Activity::TryCatch pattern match at around line 815\n2. Copy implementation from compile_try_catch_node() (lines 636-673)\n3. For nested scenarios, call compile_from_called_scenario() recursively instead of compile_from_node()\n4. Handle try branch via BranchType::TryBranch\n5. Handle catch branch via BranchType::CatchBranch\n\nThe implementation should:\n- Create PushErrorHandler instruction\n- Recursively compile try block\n- Create PopErrorHandler instruction\n- Add unconditional Jump to skip catch block\n- Recursively compile catch block\n- Backpatch error handler target and skip jump target\n\nADDITIONAL INFO:\n- This is part of asymmetric control flow support between scenarios\n- Main scenario (lines 636-673) correctly compiles TryCatch nodes\n- Nested scenario falls to default handler (silent failure)\n- Currently: try-catch in nested scenarios doesn't work at all\n- Impact: Error handling broken in nested scenarios\n- Severity: HIGH - silently breaks error handling\n- Dependency: Independent, can be fixed anytime\n- Must call compile_from_called_scenario() for recursion, not compile_from_node()\n- Requires careful adaptation of try/catch node compilation","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-27T01:37:30.5299953+05:00","updated_at":"2025-12-27T01:37:30.5299953+05:00"}
{"id":"rpa-4s0","title":"Investigate LLM-driven RPA project generation","description":"Research and explore feasibility of using LLMs to automatically generate RPA workflows from natural language descriptions or requirements","status":"open","priority":4,"issue_type":"feature","created_at":"2025-12-25T17:36:31.7534616+05:00","updated_at":"2025-12-25T21:33:53.7671035+05:00"}
{"id":"rpa-5m5","title":"Add allow attributes to intentional cast operations","description":"Add #[allow(clippy::cast_precision_loss)] and #[allow(clippy::cast_possible_truncation)] to intentional casts. Affects: execution.rs lines 360, 403, 423, 429, 434 for i64\u003c-\u003ef64 conversions in loop handling","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T16:00:05.8315915+05:00","updated_at":"2025-12-25T16:11:53.0074129+05:00"}
{"id":"rpa-6q3","title":"Fix single-character lifetime names (use 'lifetime or 'scope)","description":"Replace single-character lifetime names 'a with more descriptive names: (1) execution.rs:22 and 100 - IrExecutor\u003c'a, L\u003e struct and impl, (2) ir.rs:140 and 174 - IrBuilder\u003c'a\u003e struct and impl, (3) validation.rs:94 and 99 - ScenarioValidator\u003c'a\u003e struct and impl. Use names like 'exec, 'builder, 'val etc.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T16:02:58.3712822+05:00","updated_at":"2025-12-25T16:13:04.7939616+05:00"}
{"id":"rpa-7e7","title":"Implement Loop node compilation in nested scenarios","description":"PROBLEM:\nLoop nodes in nested scenarios fall through to the default handler and are not compiled. The compile_from_called_scenario() function doesn't handle Activity::Loop, causing loop bodies to never execute in called scenarios.\n\nLocation: ir.rs lines 731-821 (missing Activity::Loop handler)\n\nSOLUTION:\nAdd Loop node handling to compile_from_called_scenario():\n1. Add Activity::Loop { start, end, step, index } pattern match at around line 815\n2. Copy implementation from compile_loop_node() (lines 512-580)\n3. For nested scenarios, call compile_from_called_scenario() recursively instead of compile_from_node()\n4. Handle body node via BranchType::LoopBody\n5. Handle after-loop node via BranchType::Default\n\nThe implementation should:\n- Create LoopInit instruction\n- Create LoopLog instruction\n- Create LoopCheck instruction\n- Recursively compile loop body\n- Create LoopNext instruction\n- Recursively compile after-loop node\n- Backpatch body and end targets\n\nADDITIONAL INFO:\n- This is part of asymmetric control flow support between scenarios\n- Main scenario (lines 512-580) correctly compiles Loop nodes\n- Nested scenario falls to default handler (silent failure)\n- Currently: loops in nested scenarios don't execute at all\n- Impact: Control flow broken in nested scenarios\n- Severity: HIGH - silently breaks loops\n- Dependency: Independent, can be fixed anytime\n- Must call compile_from_called_scenario() for recursion, not compile_from_node()\n- Requires careful adaptation of body/end node compilation","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-27T01:37:25.6758857+05:00","updated_at":"2025-12-27T01:37:25.6758857+05:00"}
{"id":"rpa-7hd","title":"Fix undo/redo grouping: scenario creation reverts all at once instead of one by one","description":"## Problem\nWhen creating multiple scenarios rapidly (e.g., create scenario 1, create scenario 2, create scenario 3), pressing undo reverts ALL scenario creations at once instead of reverting them one by one.\n\n**Root Cause:**\n- Current code calls `snapshot_undo_state()` after each scenario is added (line 1142 in main.rs)\n- egui's `Undoer` uses `stable_time` (default 1.0 second) to decide when to create undo points\n- When scenarios are created rapidly (within 1 second), they all occur during the same \"flux\" (ongoing change period)\n- The `Undoer` only creates ONE undo point when the flux stabilizes, grouping all rapid changes together\n- Result: One undo reverts all scenarios created during that flux period\n\n## Implementation\n1. Replace `snapshot_undo_state()` call at line 1142 with `undo_redo.add_undo(\u0026self.project)`\n2. Expose `add_undo()` method in `UndoRedoManager` to make it public (currently private/dead_code)\n3. `add_undo()` forces an immediate undo point without waiting for `stable_time`, creating a separate snapshot for each scenario\n\n## Solution\nEach scenario creation will now be a distinct undo point. User can create multiple scenarios and undo them one at a time.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-27T13:45:29.8540672+05:00","updated_at":"2025-12-27T13:51:33.7629903+05:00","closed_at":"2025-12-27T13:51:33.7629903+05:00","close_reason":"Closed"}
{"id":"rpa-7id","title":"Replace UUID with Nanoid for node identifiers","description":"Replace Uuid with Nanoid for shorter, human-readable node identifiers.\n\nPROBLEM\n=======\nCurrent implementation uses uuid::Uuid for node IDs, which are 36 characters long. This is unnecessarily verbose for display in UI panels and log entries. UUIDs also impose unnecessary memory overhead when storing 10-100 nodes per scenario.\n\nSOLUTION\n========\nReplace Uuid with Nanoid (10-character string IDs) - a proven, fast ID generation library with virtually zero collision risk at our scale. IDs will remain human-readable while being ~71% shorter.\n\nKEY DECISIONS\n=============\n- Use nanoid!(NANOID_LENGTH) with compile-time configurable length\n- Store as String in structs, pass as \u0026str references to functions (zero-clone pattern)\n- No backward compatibility with old UUID-based .rpa files\n- NANOID_LENGTH constant in constants.rs (default 10, can bump to 12 if needed)\n\nFILES TO MODIFY\n===============\n1. Cargo.toml (workspace root)\n   - Add 'nanoid' to workspace.dependencies\n\n2. crates/rpa-core/src/constants.rs\n   - Add: pub const NANOID_LENGTH: usize = 10;\n\n3. crates/rpa-core/src/node_graph.rs\n   - Line 4: Change 'use uuid::Uuid;' to 'use nanoid::nanoid;'\n   - Line 266: Scenario.id: Uuid → String\n   - Line 275: Uuid::new_v4() → nanoid!(NANOID_LENGTH).into()\n   - Line 309: Node.id: Uuid → String\n   - Line 309: Uuid::new_v4() → nanoid!(NANOID_LENGTH).into()\n   - Line 342: Connection.id: Uuid → String\n   - Line 342: Uuid::new_v4() → nanoid!(NANOID_LENGTH).into()\n   - Activity enum variants storing IDs (scenario_id fields): Uuid → String\n   - All function signatures taking node IDs: change from 'id: Uuid' to 'id: \u0026str'\n   \n4. crates/rpa-core/src/ir.rs\n   - Review all uuid usage and replace with String/\u0026str pattern\n   - Update function signatures to use \u0026str for parameters\n\n5. crates/rpa-core/src/execution.rs\n   - Review all uuid usage and replace with String/\u0026str pattern\n   - Update function signatures to use \u0026str for parameters\n\n6. crates/rpa-core/src/validation.rs\n   - Review all uuid usage and replace with String/\u0026str pattern\n\n7. crates/rpa-studio/src/main.rs\n   - Review all uuid usage and replace with String/\u0026str pattern\n   - Update HashMap\u003cUuid, Uuid\u003e instances to HashMap\u003cString, String\u003e\n\n8. crates/rpa-studio/src/ui.rs\n   - Review all node.id comparisons and references\n   - Update function signatures to use \u0026str for ID parameters\n\nPATTERN TO FOLLOW\n=================\nWhen an ID is:\n- Stored in a struct: String (owns the ID)\n- Passed as parameter: \u0026str (no clone, cheap comparison)\n- Generated: nanoid!(NANOID_LENGTH).into()\n- Compared: n.id == id (String impl PartialEq\u003c\u0026str\u003e)\n\nTESTING\n=======\nAfter changes:\n1. cargo build --release (should compile without warnings)\n2. cargo clippy (fix any warnings)\n3. Verify .rpa file serialization/deserialization works\n4. Test node creation/deletion/connections in rpa-studio\n5. Verify log entries display node IDs correctly","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-26T12:26:22.9573506+05:00","updated_at":"2025-12-26T18:52:02.0380259+05:00","closed_at":"2025-12-26T18:52:02.0380259+05:00","close_reason":"Closed"}
{"id":"rpa-7xt","title":"Handle RunPowershell nodes in nested scenarios","description":"PROBLEM:\nRunPowershell nodes in nested scenarios fall through to the default handler and may not be compiled correctly. The compile_from_called_scenario() function doesn't have an explicit handler for Activity::RunPowershell, causing it to use default behavior.\n\nLocation: ir.rs lines 731-821 (missing Activity::RunPowershell handler)\n\nSOLUTION:\nAdd explicit RunPowershell node handling to compile_from_called_scenario():\n1. Add Activity::RunPowershell { code } pattern match at around line 815\n2. Copy the simple pattern from main scenario (lines 450-453):\n   - Add Instruction::RunPowershell { code: code.clone() }\n   - Call compile_default_next_called(scenario, node_id)\n\nThe implementation should be straightforward:\n\n\nADDITIONAL INFO:\n- This is part of asymmetric activity support between scenarios\n- Main scenario (lines 450-453) correctly handles RunPowershell\n- Nested scenario may fall to default handler (silent behavior)\n- Currently: behavior with RunPowershell in nested scenarios is unclear\n- Impact: Potential incorrect execution of PowerShell commands\n- Severity: LOW-MEDIUM - execution path is simple, may work anyway\n- Dependency: Independent, can be fixed anytime\n- Should be added for consistency and clarity\n- Check if default handler actually works or if explicit handler needed","status":"open","priority":2,"issue_type":"bug","created_at":"2025-12-27T01:37:57.1391932+05:00","updated_at":"2025-12-27T01:37:57.1391932+05:00"}
{"id":"rpa-8vn","title":"Fix crash when creating new project with active scenario","description":"**Problem:**\nApp crashes with 'index out of bounds' panic when user:\n1. Opens the app\n2. Creates a blank scenario (adds to scenarios vec)\n3. Clicks menu.new_project button\n\n**Root Cause:**\nWhen menu.new_project is clicked, the project is replaced with a fresh Project::new() but self.current_scenario_index is NOT reset. If the index pointed to a scenario (e.g., Some(0)), it still points there in the new empty project, causing an out-of-bounds access in get_current_scenario() at main.rs:1187.\n\n**Stack Trace Location:**\ncrates/rpa-studio/src/main.rs:1187:47\n- index out of bounds: len is 0 but index is 0\n- Triggered in render_canvas_panel() -\u003e get_current_scenario()\n\n**Solution:**\nReset self.current_scenario_index = None when creating a new project (around line 395-401 in main.rs, in the menu.new_project handler). This ensures new projects always start with main_scenario selected.\n\nNote: open_project handler already does this correctly at line 1176.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-26T22:15:15.6280846+05:00","updated_at":"2025-12-26T22:16:53.8906353+05:00","closed_at":"2025-12-26T22:16:53.8906353+05:00","close_reason":"Closed"}
{"id":"rpa-90k","title":"Fix bug: copy-pasting connected nodes between scenarios loses connections","description":"Fix copy-paste of nodes between scenarios: Connections between copied nodes are lost when pasting into a different scenario because the code only looks for connections in the destination scenario's connection list, not in the source scenario's list.\n\nSolution: Extend the clipboard structure from `Vec\u003cNode\u003e` to also store the internal connections between copied nodes. When pasting, reconstruct these connections using the ID remapping table.\n\nImplementation steps:\n1. Create ClipboardData struct { nodes: Vec\u003cNode\u003e, connections: Vec\u003cConnection\u003e }\n2. Replace clipboard: Vec\u003cNode\u003e with clipboard: ClipboardData in main.rs:112\n3. Update copy_selected_nodes() (lines 1198-1208) to capture internal connections\n4. Update paste logic (lines 1256-1264) to use clipboard.connections instead of scenario.connections\n5. Update clipboard_empty checks to use .nodes.is_empty()\n6. Test cross-scenario copy-paste preserves connections\n\nRoot cause: crates/rpa-studio/src/main.rs:1253-1264 filters connections from `get_current_scenario_mut()` which is the destination scenario, not the source.\n\nTechnical details:\n- Clipboard currently only stores: `clipboard: Vec\u003cNode\u003e` (crates/rpa-studio/src/main.rs:112)\n- Should also store: internal connections and their branch types\n- Current ID remapping: crates/rpa-studio/src/main.rs:1232-1233 creates old_to_new_id HashMap\n- This mapping can be reused to remap stored connections\n- Connection struct: crates/rpa-core/src/node_graph.rs:573-591\n- Scenario struct: crates/rpa-core/src/node_graph.rs contains connections Vec","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-25T15:50:37.7144045+05:00","updated_at":"2025-12-27T01:47:23.0164594+05:00","closed_at":"2025-12-27T01:47:23.0164594+05:00","close_reason":"Closed"}
{"id":"rpa-9mv","title":"Add missing documentation and crate-level docs","description":"Add missing documentation: (1) Add crate-level doc comment to lib.rs (line 1), (2) Add missing_docs_in_private_items documentation for internal modules and items. This is lower priority - add basic docs only where critical for API users","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-25T16:03:06.7719209+05:00","updated_at":"2025-12-25T16:13:12.6298587+05:00"}
{"id":"rpa-9vh","title":"Disable undo/redo during execution","description":"Prevent undo/redo operations while workflow is executing\n\n## Problem\nUndo/redo buttons and shortcuts should be disabled during execution to prevent state corruption.\n\n## Instructions\n1. In render_menu_bar(), when displaying Undo/Redo buttons:\n   - Check: if self.is_executing == true: disable both buttons\n   - Use ui.add_enabled(false, ...) for disabled state\n\n2. In handle_keyboard_shortcuts():\n   - Check: if self.is_executing == true: ignore Ctrl+Z and Ctrl+Y\n   - Don't call undo() or redo()\n\n3. Rationale: During execution, variables and logs are being modified\n   - We don't track variable mutations\n   - Undoing during execution could corrupt the execution state\n\n## Suggested Implementation\nAdd guard clause in both locations:\n- if self.is_executing { return; }","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-27T12:49:36.6424115+05:00","updated_at":"2025-12-27T13:17:58.7917002+05:00","closed_at":"2025-12-27T13:17:58.7917002+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-9vh","depends_on_id":"rpa-a4r","type":"blocks","created_at":"2025-12-27T12:49:55.7743008+05:00","created_by":"daemon"}]}
{"id":"rpa-9vl","title":"Intercept node add/delete mutations","description":"Record undo snapshots when nodes are added or deleted\n\n## Problem\nNodes can be added (drag from activity panel) or deleted (context menu), but these mutations are not tracked for undo/redo.\n\n## Instructions\n1. Find mutation point 1: render_canvas_panel() where dropped_activity is added (~line 250)\n   - Before modifying scenario.nodes, call: self.undo_redo.feed_state()\n   - After adding node, call: self.snapshot_undo_state()\n\n2. Find mutation point 2: handle_context_menu_action() for node deletion\n   - Wrap deletion in transaction: self.begin_undo_transaction()\n   - Delete node(s)\n   - Call: self.end_undo_transaction() to snapshot\n\n3. Handle multi-select: Group all deleted nodes into ONE undo step\n\n## Suggested Implementation\n- Add helper: fn snapshot_undo_state() { undo_redo.feed_state(time, \u0026self.project); }\n- Add helper: fn begin_undo_transaction() { transaction_in_progress = true; }\n- Add helper: fn end_undo_transaction() { snapshot + transaction_in_progress = false; }","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-27T12:49:09.9152967+05:00","updated_at":"2025-12-27T13:05:26.795584+05:00","closed_at":"2025-12-27T13:05:26.795584+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-9vl","depends_on_id":"rpa-d24","type":"blocks","created_at":"2025-12-27T12:49:53.6159409+05:00","created_by":"daemon"}]}
{"id":"rpa-a4r","title":"Implement scenario add/delete mutation tracking","description":"Record undo snapshots when scenarios are added or deleted\n\n## Problem\nScenarios affect canvas structure and should be tracked in undo/redo history.\n\n## Instructions\n1. Find scenario creation (new scenario button in sidebar)\n   - Before adding to project.scenarios: store transaction state\n   - After adding: call self.snapshot_undo_state()\n\n2. Find scenario deletion (delete context menu)\n   - Before removing: validate no active connections reference it\n   - After deletion: call self.snapshot_undo_state()\n\n3. When deleting scenario with active nodes/connections:\n   - Delete all nodes/connections first (in one transaction)\n   - Then delete scenario (second transaction)\n\n## Suggested Implementation\nReuse snapshot_undo_state() helper.\nAdd validation to prevent corruption if scenario deleted.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-27T12:49:28.9412753+05:00","updated_at":"2025-12-27T13:16:26.6868509+05:00","closed_at":"2025-12-27T13:16:26.6868509+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-a4r","depends_on_id":"rpa-eec","type":"blocks","created_at":"2025-12-27T12:49:55.4142315+05:00","created_by":"daemon"}]}
{"id":"rpa-ay8","title":"Fix IfCondition: Compile branches in correct order (true first, then false)","description":"PROBLEM:\nIn compile_from_called_scenario(), the IfCondition handler compiles the false branch first (lines 801-803) and then the true branch (lines 804-806). This is reversed from the correct order and creates incorrect control flow when combined with other If node issues.\n\nLocation: ir.rs lines 801-806\n\nSOLUTION:\nSwap the order of branch compilation:\n1. First: Compile true branch (line 804-806)\n2. Then: Compile false branch (line 801-803)\n\nThis matches the main scenario implementation in compile_if_node() which correctly compiles true branch first (lines 477-479) then false branch (lines 490-493).\n\nADDITIONAL INFO:\n- This is part of asymmetric If node handling between main and nested scenarios\n- Must be combined with other If fixes for correct control flow\n- Main scenario (lines 477-493) correctly handles: true → skip → false\n- Nested scenario (lines 801-806) incorrectly handles: false → true\n- Impact: Execution order doesn't match code intent\n- Severity: CRITICAL - causes incorrect execution order\n- Dependency: Related to rpa-c65 and other If node fixes\n- Should be applied together with skip instruction and target patching fixes","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-27T01:36:54.4411375+05:00","updated_at":"2025-12-27T01:42:04.9369899+05:00","closed_at":"2025-12-27T01:42:04.9369899+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-ay8","depends_on_id":"rpa-c65","type":"blocks","created_at":"2025-12-27T01:38:01.9529245+05:00","created_by":"daemon"}]}
{"id":"rpa-bgl","title":"Add helper methods for undo transaction management","description":"Create helper methods to simplify transaction and snapshot logic\n\n## Problem\nMultiple places in code need to call snapshot or begin/end transactions. Helper methods reduce duplication.\n\n## Instructions\n1. In impl RpaApp, add helper methods:\n   - fn snapshot_undo_state() -\u003e calls undo_redo.feed_state(time, project)\n   - fn begin_undo_transaction() -\u003e sets transaction_in_progress = true\n   - fn end_undo_transaction() -\u003e calls snapshot_undo_state() and sets transaction_in_progress = false\n\n2. These helpers centralize the logic\n3. Makes mutation interception cleaner and less error-prone\n\n## Suggested Implementation\n","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-27T12:49:45.5640734+05:00","updated_at":"2025-12-27T12:56:11.7931955+05:00","closed_at":"2025-12-27T12:56:11.7931955+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-bgl","depends_on_id":"rpa-s7l","type":"blocks","created_at":"2025-12-27T12:49:52.1293693+05:00","created_by":"daemon"}]}
{"id":"rpa-c65","title":"Fix IfCondition: Use JumpIfNot instead of JumpIf in nested scenarios","description":"PROBLEM:\nThe IfCondition node handler in compile_from_called_scenario() uses JumpIf instruction instead of JumpIfNot. This inverts the condition logic, causing incorrect branch execution in nested scenarios.\n\nLocation: ir.rs line 796\n\nSOLUTION:\nReplace Instruction::JumpIf with Instruction::JumpIfNot in the IfCondition handler for compile_from_called_scenario(). This matches the main scenario implementation in compile_if_node() which correctly uses JumpIfNot.\n\nCode change:\n- Line 796: Change 'Instruction::JumpIf' to 'Instruction::JumpIfNot'\n\nADDITIONAL INFO:\n- This is part of asymmetric If node handling between main and nested scenarios\n- Main scenario (lines 472-475) correctly uses JumpIfNot\n- Nested scenario (line 796) incorrectly uses JumpIf\n- Impact: If conditions in nested scenarios are logically inverted\n- Severity: CRITICAL - causes incorrect execution logic\n- Dependency: Should be fixed before testing If nodes in nested scenarios","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-27T01:36:49.2483625+05:00","updated_at":"2025-12-27T01:42:04.9267176+05:00","closed_at":"2025-12-27T01:42:04.9267176+05:00","close_reason":"Closed"}
{"id":"rpa-ckv","title":"Fix node tracking: Use scenario-specific or qualified node IDs","description":"PROBLEM:\nThe compiled_nodes HashSet in IrBuilder tracks node IDs globally across all scenarios using the same HashMap. This causes collisions when main scenario and nested scenarios have nodes with identical IDs (e.g., both have node 'if_1'). The second scenario's node is never compiled because it's marked as already compiled.\n\nLocation: ir.rs lines 150, 352, 363, 732, 742\n\nSOLUTION:\nEither:\nOption A: Make compiled_nodes track scenario + node ID as composite key\n- Change HashMap\u003cString, usize\u003e to HashMap\u003c(String, String), usize\u003e\n- Use (scenario_id, node_id) as key instead of just node_id\n- Update inserts and checks in both compile_from_node and compile_from_called_scenario\n\nOption B: Qualify node IDs with scenario ID\n- When inserting: node_id = format!('{}:{}', scenario_id, original_node_id)\n- Modify the function to receive scenario_id parameter\n- Update both paths (main and nested)\n\nOption C: Create separate node tracking per scenario\n- Create HashMap\u003cString, HashSet\u003cString\u003e\u003e for per-scenario tracking\n- Key: scenario ID, Value: set of compiled nodes in that scenario\n\nADDITIONAL INFO:\n- This is a structural issue affecting all scenario compilation\n- Affects both main scenario (lines 352, 363) and nested (lines 732, 742)\n- Impact: Nodes in nested scenarios may be skipped if ID collides with main scenario\n- Severity: HIGH - causes incomplete IR generation\n- Dependency: Independent of If node fixes but affects overall compilation correctness\n- Should use Option A or C for cleaner implementation\n- Requires careful testing to ensure all scenarios compile completely","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-27T01:37:13.4451845+05:00","updated_at":"2025-12-27T01:37:13.4451845+05:00"}
{"id":"rpa-cma","title":"Refactor output pin positioning to per-node configurability","description":"## Problem\nOutput pin positioning uses a complicated hardcoded system with many special cases for different activity types. The logic has grown complex with match statements covering IfCondition, Loop, While, TryCatch, and activities with error outputs. This makes it difficult to customize pin layouts for individual nodes.\n\n## Instruction\nRefactor the pin positioning system to:\n1. Replace get_output_pin_pos_by_index() with a new get_output_pin_positions() method that returns Vec\u003cPos2\u003e\n2. Add get_output_pin_positions_vertical() with per-node match statement defining custom formulas\n3. Add get_output_pin_positions_horizontal() with simple even spacing on right edge\n4. Refactor draw_node_transformed() in ui.rs to use generic pin rendering loop\n5. Remove special-case activity handling from draw_node_transformed()\n\n## Solution\n- node_graph.rs: Replace complex get_output_pin_pos_by_index (lines 422-483) with new methods\n  - Default: single pin at center bottom (Log, Delay, SetVariable, Evaluate)\n  - Start: single output at center bottom\n  - Activities with error output: default at center bottom, error at right center\n  - End/Note: no output pins\n  - Migrate IfCondition, Loop, While, TryCatch, CallScenario, RunPowershell to match statement\n- ui.rs: Simplify draw_node_transformed (lines 1318-1575) with generic loop over pin positions\n- Keep get_output_pin_count() and get_pin_index_for_branch() unchanged\n- No serialization changes required","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-26T21:39:17.596495+05:00","updated_at":"2025-12-26T22:05:54.8927459+05:00","closed_at":"2025-12-26T22:05:54.8927459+05:00","close_reason":"Closed"}
{"id":"rpa-cpu","title":"Create UndoRedoManager in rpa-studio","description":"Create new undo_redo.rs module with UndoRedoManager struct and core methods\n\n## Problem\nUndo/redo system needs a centralized manager to wrap egui's Undoer and handle state snapshots.\n\n## Instructions\n1. Create: crates/rpa-studio/src/undo_redo.rs\n2. Implement UndoRedoManager with:\n   - Field: undoer: egui::util::undoer::Undoer\u003cProject\u003e\n   - Field: history_limit: usize (from constants)\n   - Method: new() -\u003e Self\n   - Method: feed_state(\u0026mut self, time: f64, project: \u0026Project)\n   - Method: undo(\u0026self, project: \u0026Project) -\u003e Option\u003cProject\u003e\n   - Method: redo(\u0026self, project: \u0026Project) -\u003e Option\u003cProject\u003e\n   - Method: has_undo(\u0026self, project: \u0026Project) -\u003e bool\n   - Method: has_redo(\u0026self, project: \u0026Project) -\u003e bool\n   - Method: clear_history(\u0026mut self)\n\n## Suggested Implementation\nUse egui's Undoer\u003cT\u003e pattern from the official demo:\n- Call feed_state() whenever project mutates\n- Use has_undo/has_redo for button enable states\n- Implement undo() and redo() to restore snapshots","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-27T12:48:53.8618471+05:00","updated_at":"2025-12-27T12:54:33.2096431+05:00","closed_at":"2025-12-27T12:54:33.2096431+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-cpu","depends_on_id":"rpa-se9","type":"blocks","created_at":"2025-12-27T12:49:51.3282475+05:00","created_by":"daemon"}]}
{"id":"rpa-d24","title":"Implement undo() and redo() methods","description":"Implement actual undo and redo functionality in RpaApp\n\n## Problem\nUndo/redo buttons and shortcuts exist but don't actually restore state.\n\n## Instructions\n1. In impl RpaApp, add two methods:\n   - fn undo(\u0026mut self) { ... }\n   - fn redo(\u0026mut self) { ... }\n\n2. In undo():\n   - Call: let restored = self.undo_redo.undo(\u0026self.project);\n   - If Some(new_project): self.project = new_project;\n   - Clear selection and transient state\n   - Request repaint\n\n3. In redo():\n   - Same pattern as undo() but call redo() instead\n   - Restore to next state in history\n\n## Suggested Implementation\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-27T12:49:32.6231703+05:00","updated_at":"2025-12-27T13:03:22.0404571+05:00","closed_at":"2025-12-27T13:03:22.0404571+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-d24","depends_on_id":"rpa-hy9","type":"blocks","created_at":"2025-12-27T12:49:53.2180467+05:00","created_by":"daemon"}]}
{"id":"rpa-d5u","title":"Open Last Project on Startup","description":"Implement optional feature to automatically open the most recently opened project on startup.\n\n## ⚠️ STRICT REQUIREMENT\n**DO NOT ATTEMPT THIS TASK UNTIL 'Persist Global Settings to Config File' (rpa-0mt) IS CLOSED.**\nThis task depends on the config file infrastructure implemented in rpa-0mt.\n\n## Requirements\n\n1. **Settings Extension**\n   - Add to AppSettings struct: open_last_project: bool (default false)\n   - Add to AppSettings struct: last_project_path: Option\u003cPathBuf\u003e\n   - Both fields persist via config file (rpa-0mt)\n\n2. **Settings UI**\n   - Add checkbox in Settings dialog: 'Open last project on startup'\n   - Display current last project path (read-only text field or info label)\n   - Checkbox toggles the setting\n\n3. **Startup Logic**\n   - During app initialization, after loading settings:\n     - If open_last_project is true AND last_project_path exists as valid file\n       - Load the project via open_project()\n     - If open_last_project is true BUT file missing/deleted\n       - Open blank project (default behavior)\n       - Log ERROR to execution panel: 'Last project file not found: {path}. Opening blank project.'\n     - If open_last_project is false\n       - Open blank project (current behavior)\n\n4. **Track Last Project**\n   - Update last_project_path after successful project load (open_project())\n   - Update last_project_path after successful project save (save_project_as())\n   - Both require calling save_settings() to persist config\n\n5. **Edge Cases**\n   - First launch (no previous project): Opens blank project\n   - Corrupted path in config: Treated as missing file\n   - New project created and saved: Becomes the 'last project'\n   - User manually opens different project: Updates last_project_path\n\n## Files to Modify\n- crates/rpa-studio/src/main.rs (AppSettings, RpaApp::default, open_project, save_project_as, Settings dialog UI)\n\n## Logging Format\nLogEntry {\n    timestamp: '[hh:mm.ss]' (auto-generated),\n    level: LogLevel::Error,\n    activity: 'SYSTEM',\n    message: 'Last project file not found: /path/to/file. Opening blank project.'\n}\n\n## Notes\n- Reuse save_settings()/load_settings() from rpa-0mt\n- Use dirs::config_dir() for config path consistency\n- All UI strings use i18n t!() macro","status":"open","priority":4,"issue_type":"feature","created_at":"2025-12-25T17:54:31.5137861+05:00","updated_at":"2025-12-25T17:54:39.0271278+05:00","dependencies":[{"issue_id":"rpa-d5u","depends_on_id":"rpa-0mt","type":"blocks","created_at":"2025-12-25T17:54:41.4086341+05:00","created_by":"daemon"}]}
{"id":"rpa-d5y","title":"Replace wildcard enum imports with explicit imports","description":"Replace wildcard enum imports with explicit imports. Specifically in activity_metadata.rs line 163: change 'use ActivityCategory::*' to explicit variant imports","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T15:59:56.770678+05:00","updated_at":"2025-12-25T16:11:45.9369139+05:00"}
{"id":"rpa-dh8","title":"Fix item ordering to match clippy requirements (alphabetical/grouped)","description":"Fix item ordering in activity_metadata.rs: (1) Move START_METADATA static (line 283) before ActivityCategory impl (line 271), (2) Reorder ActivityCategory variants alphabetically, (3) Reorder ColorCategory variants alphabetically (line 15), (4) Reorder PropertyType variants alphabetically (line 31), (5) Reorder PropertyDef fields alphabetically (line 41), (6) Reorder ActivityMetadata fields alphabetically (line 47)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T16:03:03.1495624+05:00","updated_at":"2025-12-25T16:13:09.2096895+05:00"}
{"id":"rpa-dw5","title":"Add #[must_use] attributes to pure functions","description":"Add #[must_use] attributes to pure functions that return values. Affects: activity_metadata.rs (lines 58 for_activity, 76 all_activities, 158 activities_by_category, 272 translation_key), execution.rs (lines 48 get_timestamp, 95 is_stopped)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T15:59:54.2031044+05:00","updated_at":"2025-12-25T16:11:56.4284681+05:00"}
{"id":"rpa-eec","title":"Implement property edit debouncing","description":"Debounce property edit snapshots so each keystroke doesn't create undo state\n\n## Problem\nWhen user edits text properties (node name, activity parameters), each keystroke creates a new undo state, making history unusable.\n\n## Instructions\n1. In render_right_panel() where properties are edited\n2. For each text_edit_singleline or similar:\n   - Track if value changed\n   - If changed: reset debounce timer to 0\n\n3. In update() loop, decrement property_edit_debounce timer by delta_time\n4. When timer \u003e= PROPERTY_EDIT_DEBOUNCE_MS (500ms):\n   - Call: self.snapshot_undo_state()\n   - Reset timer\n\n## Suggested Implementation\nAdd to RpaApp.update():\n- Decrement: self.property_edit_debounce -= ctx.input(|i| i.stable_dt);\n- Check: if property_edit_debounce \u003e= UiConstants::PROPERTY_EDIT_DEBOUNCE_MS\n- Snapshot and reset timer","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-27T12:49:25.19907+05:00","updated_at":"2025-12-27T13:14:47.6468831+05:00","closed_at":"2025-12-27T13:14:47.6468831+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-eec","depends_on_id":"rpa-vtl","type":"blocks","created_at":"2025-12-27T12:49:55.0451898+05:00","created_by":"daemon"}]}
{"id":"rpa-fay","title":"Implement While node compilation in nested scenarios","description":"PROBLEM:\nWhile nodes in nested scenarios fall through to the default handler and are not compiled. The compile_from_called_scenario() function doesn't handle Activity::While, causing while loop bodies to never execute in called scenarios.\n\nLocation: ir.rs lines 731-821 (missing Activity::While handler)\n\nSOLUTION:\nAdd While node handling to compile_from_called_scenario():\n1. Add Activity::While { condition } pattern match at around line 815\n2. Copy implementation from compile_while_node() (lines 582-634)\n3. For nested scenarios, call compile_from_called_scenario() recursively instead of compile_from_node()\n4. Handle body node via BranchType::LoopBody\n5. Handle after-loop node via BranchType::Default\n\nThe implementation should:\n- Parse the condition expression\n- Create WhileCheck instruction\n- Recursively compile loop body\n- Add Jump back to condition check\n- Recursively compile after-loop node\n- Backpatch targets\n\nADDITIONAL INFO:\n- This is part of asymmetric control flow support between scenarios\n- Main scenario (lines 582-634) correctly compiles While nodes\n- Nested scenario falls to default handler (silent failure)\n- Currently: while loops in nested scenarios don't execute at all\n- Impact: Control flow broken in nested scenarios\n- Severity: HIGH - silently breaks while loops\n- Dependency: Independent, can be fixed anytime\n- Must call compile_from_called_scenario() for recursion, not compile_from_node()\n- Requires careful adaptation of body/end node compilation","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-27T01:37:20.4719808+05:00","updated_at":"2025-12-27T01:37:20.4719808+05:00"}
{"id":"rpa-g7i","title":"Fix undo/redo grouping: node movement reverts to original position instead of stepping through moves","description":"## Problem\nWhen moving a node (e.g., drag from position A to B, release, pause, drag from B to C, release), pressing undo reverts the node all the way back to the original position instead of stepping through each move (C → B → original).\n\n**Root Cause:**\n- Current code uses `begin_undo_transaction()` on drag start (line 335) and `end_undo_transaction()` on drag end (line 347)\n- During a drag, the node position continuously updates but only one snapshot is created\n- The transaction pattern groups ALL movement within a continuous drag as ONE undo step (correct)\n- However, the issue extends to multiple separate drags being grouped together\n- This suggests the flux is not properly stabilizing between drag operations, or transactions are spanning across multiple user actions\n\n## Implementation\n1. Delete `begin_undo_transaction()` and `end_undo_transaction()` method calls from drag handling (lines 335, 347)\n2. Add new method `force_stabilize_flux(current_time, project)` to `UndoRedoManager`\n3. On `drag_ended`, call `force_stabilize_flux()` with current time to force the `Undoer` to create an undo point\n4. `force_stabilize_flux()` makes a time jump large enough to exceed `stable_time`, triggering undo point creation\n5. Apply same fix to resize operations (lines 338, 350)\n\n## Solution\nEach separate drag/resize operation will create its own undo point. User can:\n- Drag node A→B, release\n- Drag node B→C, release  \n- Undo → goes back to B\n- Undo → goes back to original position","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-27T13:45:36.2378252+05:00","updated_at":"2025-12-27T13:51:33.7681177+05:00","closed_at":"2025-12-27T13:51:33.7681177+05:00","close_reason":"Closed"}
{"id":"rpa-gpi","title":"Add Cut functionality (Ctrl+X) for nodes with connections","description":"Implement Cut operation that copies selected nodes and their internal connections, then deletes them. Should be available via: 1) Right-click context menu 2) Ctrl+X keybind. Should preserve connections between cut nodes when pasting.\n\n⚠️ PREREQUISITE: Verify that issue rpa-90k is CLOSED before starting work. This task depends on the clipboard enhancement that rpa-90k implements.\n\nImplementation steps (after rpa-90k is complete):\n1. Add Cut variant to ContextMenuAction enum in crates/rpa-studio/src/ui.rs:12-18\n2. Update canvas context menu (ui.rs:242-276) to show Cut button when nodes selected\n3. Update node context menu (ui.rs:730-752) to show Cut button\n4. Create cut_selected_nodes() function in main.rs that:\n   - Calls copy_selected_nodes() to populate clipboard with nodes + connections\n   - Gets selected node IDs\n   - Removes those nodes from current scenario\n   - Clears selection\n5. Add Ctrl+X keybind handler in main.rs (lines 763-822)\n6. Update handle_context_menu_action() to handle ContextMenuAction::Cut\n7. Add localization strings: context_menu.cut in all locale files\n8. Test: Cut single node, cut multiple connected nodes, cut and paste between scenarios","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-25T15:52:58.3314124+05:00","updated_at":"2025-12-27T11:40:35.366504+05:00","closed_at":"2025-12-27T11:40:35.366504+05:00","close_reason":"Closed"}
{"id":"rpa-h1a","title":"Fix missing localization keys in ru.yml and kz.yml","description":"Add missing localization keys and fix FIXME entries in Russian (crates/rpa-studio/locales/ru.yml) and Kazakh (crates/rpa-studio/locales/kz.yml) files.\n\nMissing keys (3 total):\n1. bottom_bar.clear - English value: \"❎Clear\"\n2. variables.undefined - English value: \"Undefined\"\n3. settings_dialog.log_entry_count - English value: \"Max log entry count:\"\n\nFIXME entries requiring proper translation:\n\nRussian (ru.yml) - 4 entries:\n1. Line 27: activity_buttons.evaluate - has \"+ Evaluate FIXME\"\n2. Line 40: activity_names.evaluate - has \"Evaluate FIXME\"\n3. Line 60: properties.evaluate_expression - has \"Expression: FIXME\"\n4. Line 129: system_messages.invalid_variable_value - duplicate entry with English text instead of Russian\n\nKazakh (kz.yml) - 3 entries:\n1. Line 27: activity_buttons.evaluate - has \"+ Evaluate FIXME\"\n2. Line 40: activity_names.evaluate - has \"Evaluate FIXME\"\n3. Line 60: properties.evaluate_expression - has \"Expression: FIXME\"\n\nAfter making changes, run 'cargo run --bin validate_locale' to verify all localization files are complete and consistent.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T22:38:51.3937604+05:00","updated_at":"2025-12-25T22:42:57.8349532+05:00","closed_at":"2025-12-25T22:42:57.8349532+05:00","close_reason":"Closed"}
{"id":"rpa-hy9","title":"Add keyboard shortcuts for undo/redo","description":"Implement Ctrl+Z and Ctrl+Y keyboard shortcuts for undo/redo operations\n\n## Problem\nUsers expect standard keyboard shortcuts (Ctrl+Z for undo, Ctrl+Y for redo).\n\n## Instructions\n1. In crates/rpa-studio/src/main.rs, find handle_keyboard_shortcuts() method\n2. Add keyboard event handling:\n   - If Ctrl+Z pressed AND not is_executing: call self.undo()\n   - If Ctrl+Y pressed AND not is_executing: call self.redo()\n\n3. Ensure shortcuts are disabled during execution (when is_executing == true)\n\n## Suggested Implementation\nIn handle_keyboard_shortcuts(), add:\n- Check ctx.input() for key_pressed() events\n- Disable when self.is_executing == true\n- Call undo() or redo() methods (to be implemented)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-27T12:49:05.3303086+05:00","updated_at":"2025-12-27T12:57:55.1662117+05:00","closed_at":"2025-12-27T12:57:55.1662117+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-hy9","depends_on_id":"rpa-1co","type":"blocks","created_at":"2025-12-27T12:49:52.8568415+05:00","created_by":"daemon"}]}
{"id":"rpa-i4o","title":"Replace match on bool with if/else expressions","description":"Replace match on bool with if/else expressions. Affects: execution.rs lines 233-236 where match is used on boolean result from interruptible_sleep","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T15:59:59.3748465+05:00","updated_at":"2025-12-25T21:26:25.6736317+05:00","closed_at":"2025-12-25T21:26:25.6736317+05:00","close_reason":"Closed"}
{"id":"rpa-in7","title":"Add allow attributes to intentionally long functions","description":"Add #[allow(clippy::too_many_lines)] to functions exceeding 100 lines. Affects: activity_metadata.rs (line 158 for activities_by_category), execution.rs (line 142 for execute_instruction)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T15:59:58.058632+05:00","updated_at":"2025-12-25T16:11:47.0718097+05:00"}
{"id":"rpa-kdk","title":"Fix clippy needless_borrow warnings in evaluator.rs tests","description":"Remove unnecessary borrows in 5 test cases in evaluator.rs:615,624,633,642,651. Change \u0026variables.values() to variables.values() in eval_expr calls.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T15:55:39.7992663+05:00","updated_at":"2025-12-25T15:55:39.7992663+05:00"}
{"id":"rpa-kfh","title":"Add #[inline] hints to small methods and update visibility (pub/private consistency)","description":"Fix visibility consistency and add #[inline]: (1) execution.rs:18 - make 'variables' field private (partial_pub_fields warning), (2) node_graph.rs:145 - make 'max_entry_count' field private. Add #[inline] hints to small methods throughout the codebase as suggested by clippy","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T16:03:05.6213548+05:00","updated_at":"2025-12-25T16:13:11.4882945+05:00"}
{"id":"rpa-kz3","title":"Fix needless_borrow in evaluator.rs","description":"Fix needless_borrow warnings in crates/rpa-core/src/evaluator.rs at lines 614, 623, 632, 641, 650. Remove \u0026 before variables.values() calls.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-25T21:41:48.3936857+05:00","updated_at":"2025-12-25T21:45:16.2103252+05:00","closed_at":"2025-12-25T21:45:16.2103252+05:00","close_reason":"Closed"}
{"id":"rpa-mz8","title":"Fix undo/redo: multiple drag operations group into single undo point","description":"## Problem\nWhen moving multiple nodes (e.g., drag node A, then drag node B), pressing undo reverts both nodes to their original positions instead of reverting them one by one. Same issue occurs when dragging the same node multiple times with pauses between drags - all movement is reverted at once.\n\n**Root Cause:**\n- Current code uses `force_stabilize_flux()` which calls `feed_state(current_time + 1.5)` \n- This triggers undo point creation via the `Undoer`'s stable_time mechanism\n- However, the flux state is NOT cleared - it persists after the undo point is created\n- When a second drag operation starts, it's part of the same ongoing flux period\n- The `Undoer` groups both drag operations as a single flux change, creating only ONE undo point for both\n\n**Root Cause Details:**\nLooking at egui's `Undoer::feed_state()`:\n- When flux is active and state changes, it updates `flux.latest_change_time` and `flux.latest_state`\n- When `feed_state()` is called with `current_time + 1.5`, it creates an undo point via `add_undo()`\n- But the flux object is NOT cleared, so `self.flux` still points to a Flux instance\n- Next drag operation detects the existing flux and treats it as part of ongoing changes\n\n## Implementation\n1. Replace `force_stabilize_flux()` calls on line 326-331 (drag_ended) and 334-339 (resize_ended) with direct `add_undo()` calls\n2. Change from:\n   ```rust\n   if drag_ended \u0026\u0026 !self.is_executing {\n       let time = SystemTime::now()\n           .duration_since(SystemTime::UNIX_EPOCH)\n           .unwrap()\n           .as_secs_f64();\n       self.undo_redo.force_stabilize_flux(time, \u0026self.project);\n   }\n   ```\n   To:\n   ```rust\n   if drag_ended \u0026\u0026 !self.is_executing {\n       self.undo_redo.add_undo(\u0026self.project);\n   }\n   ```\n3. Apply same change to resize_ended block (lines 334-339)\n4. Optionally remove `force_stabilize_flux()` from UndoRedoManager if no longer used\n\n## Solution\nEach drag or resize operation will now create an immediate, discrete undo point. User can:\n- Drag node A to position B, release\n- Drag node C to position D, release\n- Undo → node C returns to original position (only C affected)\n- Undo → node A returns to original position (only A affected)\n\nSame behavior for multiple moves of the same node with pauses between drags.","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-27T14:00:13.5280009+05:00","updated_at":"2025-12-27T14:00:13.5280009+05:00"}
{"id":"rpa-nr7","title":"Add # Errors documentation to public Result-returning functions","description":"Add # Errors sections to public functions returning Result. Affects: evaluator.rs (lines 502, 518 for parse_expr and eval_expr), execution.rs (line 118 for execute method)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T16:00:08.3333513+05:00","updated_at":"2025-12-25T16:11:55.2660231+05:00"}
{"id":"rpa-o08","title":"Fix needless_pass_by_value warnings (use references)","description":"Fix needless_pass_by_value warnings by using references instead of pass-by-value for types that don't need ownership. Affects: execution.rs (lines 598, 688, 724 for Sender; 691, 727 for IrProgram), evaluator.rs (line 324 for Token parameter)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T16:00:01.9511025+05:00","updated_at":"2025-12-25T17:09:02.9187972+05:00","closed_at":"2025-12-25T17:09:02.9187972+05:00","close_reason":"Closed"}
{"id":"rpa-oc9","title":"Intercept connection add/delete mutations","description":"Record undo snapshots when connections are added or deleted\n\n## Problem\nConnections can be created or deleted, but mutations are not tracked for undo/redo.\n\n## Instructions\n1. Find mutation point: Connection creation in render_canvas_panel() or ui::render_node_graph()\n   - When CanvasResult contains new connection\n   - Call: self.undo_redo.feed_state() after adding connection\n\n2. Find mutation point: Connection deletion in handle_context_menu_action()\n   - When deleting a connection\n   - Call: self.undo_redo.feed_state() after removal\n\n3. Handle connection deletion with node deletion: Group together in same transaction\n\n## Suggested Implementation\nUse the same snapshot helper as node operations:\n- fn snapshot_undo_state() { undo_redo.feed_state(time, \u0026self.project); }","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-27T12:49:13.1636619+05:00","updated_at":"2025-12-27T13:08:25.1027576+05:00","closed_at":"2025-12-27T13:08:25.1027576+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-oc9","depends_on_id":"rpa-9vl","type":"blocks","created_at":"2025-12-27T12:49:53.9677469+05:00","created_by":"daemon"}]}
{"id":"rpa-ru0","title":"Convert canvas flow from horizontal to vertical with configurable direction","description":"## Complexity Level: Medium\n\nThis task requires changes across 2-3 core files with careful coordinate system transformations. The existing architecture is well-structured, making this feasible with focused effort.\n\n---\n\n## Problem\nCurrently the canvas uses horizontal left-to-right flow:\n- Input pins on left edge (x=0, y=height/2)\n- Output pins on right edge (x=width, y varies)\n- Bezier connections curve horizontally with control offsets on X-axis\n- New nodes are spaced horizontally based on X distance\n\nThis limits workflow readability for complex scenarios. Users need vertical top-to-bottom flow for better vertical screen usage and clearer step-by-step visualization.\n\n## Solution\nAdd a compile-time constant `FLOW_DIRECTION` to toggle between Horizontal and Vertical layouts. All layout logic will be conditioned on this constant using match statements, allowing easy switching without runtime overhead.\n\n### Pin Positioning Changes\n\n**Input pins:**\n- Horizontal: left-center (0.0, height/2)\n- Vertical: top-center (width/2, 0.0)\n\n**Output pins (default - single output):**\n- Horizontal: right-center (width, height/2)\n- Vertical: bottom-center (width/2, height)\n\n**Output pins (dual outputs - control flow, error handling):**\n- Horizontal: right-top (width, height/4) and right-bottom (width, 3×height/4)\n- Vertical: bottom-left (width/4, height) and bottom-right (3×width/4, height)\n\n**Error pins (always right-center, no exceptions):**\n- Position: (width, height/2) regardless of flow direction\n- Drawn separately, visually distinct from default pins\n\n## Implementation Details\n\n### Files to Modify (relative to repo root)\n\n1. **crates/rpa-core/src/constants.rs**\n   - Add FlowDirection enum (Horizontal, Vertical)\n   - Add FLOW_DIRECTION constant to UiConstants (default: Vertical)\n   - Lines: New (insert after line 3)\n\n2. **crates/rpa-core/src/node_graph.rs**\n   - Update get_input_pin_pos() [lines 375-377]\n     - Horizontal: position + (0.0, height/2)\n     - Vertical: position + (width/2, 0.0)\n   \n   - Update get_output_pin_pos() [lines 379-381]\n     - Horizontal: position + (width, height/2)\n     - Vertical: position + (width/2, height)\n   \n   - Update get_output_pin_pos_by_index(index) [lines 411-439]\n     - Horizontal: right edge at height/4 and 3×height/4\n     - Vertical: bottom edge at width/4 and 3×width/4\n   \n   - Consider adding get_error_pin_pos() method for right-center positioning\n   \n   - Use pattern: match UiConstants::FLOW_DIRECTION { ... }\n\n3. **crates/rpa-studio/src/ui.rs** - Bezier Control Point Calculations (4 locations)\n   \n   **Location A: find_connection_near_point() [lines 145-148]**\n   - Horizontal: distance = |end.x - start.x|; control1 = start + (offset, 0); control2 = end - (offset, 0)\n   - Vertical: distance = |end.y - start.y|; control1 = start + (0, offset); control2 = end - (0, offset)\n   \n   **Location B: find_intersecting_connections() [lines 208-211]**\n   - Same changes as Location A\n   \n   **Location C: draw_connection_transformed() [lines 1465-1468]**\n   - Same changes as Location A\n   \n   **Location D: Connection preview during drag [lines 981-983]**\n   - Same changes as Location A\n\n4. **crates/rpa-studio/src/ui.rs** - Node Insertion Spacing [lines 823-836]\n   - Horizontal: measure horizontal_distance on x-axis, expand nodes along x\n   - Vertical: measure vertical_distance on y-axis, expand nodes along y\n   - Change from: node.position.x adjustments\n   - Change to: node.position.y adjustments\n\n5. **crates/rpa-studio/src/ui.rs** - Pin Drawing in draw_node_transformed() [lines 1225-1427]\n   \n   **Input pin rendering [lines 1225-1237]**\n   - Update text position offset from Vec2::new(12.0 * zoom, 0.0) to appropriate offset for new location\n   \n   **Output pin text labels [lines 1259-1427]**\n   - All pin labels (\"T\", \"F\", \"B\", \"N\", \"S\", \"E\", \"C\") need repositioned\n   - Horizontal: labels right of pins with +X offset\n   - Vertical: labels above/below/left of pins with appropriate offsets\n   \n   **Error pin rendering (new)**\n   - Always render on right side at (width, height/2)\n   - Use label \"E\" or appropriate marker\n   - Offset text right: Vec2::new(12.0 * zoom, 0.0)\n\n### Implementation Pattern\n\nUse consistent conditional throughout:\n\n```rust\nmatch UiConstants::FLOW_DIRECTION {\n    FlowDirection::Horizontal =\u003e { /* current logic */ },\n    FlowDirection::Vertical =\u003e { /* new logic */ },\n}\n```\n\nThis keeps both implementations visible and maintainable side-by-side.\n\n## Testing Notes\n\n- After implementation, toggle FLOW_DIRECTION between Horizontal and Vertical\n- Verify pin positions change correctly in both directions\n- Test connection drawing: Bezier curves should route perpendicular to flow\n- Test node insertion: dragging nodes onto connections should space vertically (vertical mode)\n- Verify error pins always appear on right edge\n- Run cargo clippy and cargo build --release\n- Test with complex scenarios (nested conditions, loops with error handlers)\n\n## Related Notes\n\n- No new data structures needed (constants-only approach)\n- No user settings required (compile-time configuration)\n- Manual node positioning maintained (no auto-layout)\n- Both implementations coexist in code (easy to toggle)\n- See BEZIER_CURVES_ANALYSIS.md for visual examples of connection routing","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-25T22:28:12.0137484+05:00","updated_at":"2025-12-26T11:40:10.7182693+05:00","closed_at":"2025-12-26T11:40:10.7182693+05:00","close_reason":"Closed"}
{"id":"rpa-s7l","title":"Integrate UndoRedoManager into RpaApp struct","description":"Add undo_redo field and debounce timer to RpaApp, initialize in Default impl\n\n## Problem\nRpaApp needs to hold the UndoRedoManager instance and track property edit debounce state.\n\n## Instructions\n1. In crates/rpa-studio/src/main.rs, add to RpaApp struct (after line 125):\n   - pub undo_redo: UndoRedoManager,\n   - pub property_edit_debounce: f32,\n   - pub transaction_in_progress: bool,\n\n2. Add mod undo_redo; at top of main.rs (after other mods)\n\n3. In impl Default for RpaApp:\n   - Initialize: undo_redo: UndoRedoManager::new(UiConstants::UNDO_HISTORY_LIMIT),\n   - Initialize: property_edit_debounce: 0.0,\n   - Initialize: transaction_in_progress: false,\n\n## Suggested Implementation\nImport: use crate::undo_redo::UndoRedoManager;\nCreate as part of Default initialization.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-27T12:48:57.7257423+05:00","updated_at":"2025-12-27T12:55:34.2362131+05:00","closed_at":"2025-12-27T12:55:34.2362131+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-s7l","depends_on_id":"rpa-cpu","type":"blocks","created_at":"2025-12-27T12:49:51.7106703+05:00","created_by":"daemon"}]}
{"id":"rpa-sct","title":"Move pub use exports to public modules instead of re-exports","description":"Convert pub use re-exports in lib.rs to public modules: (1) lines 11-13 activity_metadata exports, (2) line 14 constants exports, (3) lines 15-17 execution exports, (4) line 19 ir exports, (5) lines 20-22 node_graph exports, (6) lines 24-26 validation exports, (7) line 27 variables exports","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T16:03:04.3917349+05:00","updated_at":"2025-12-25T16:13:10.3681622+05:00"}
{"id":"rpa-se9","title":"Add undo/redo constants to constants.rs","description":"Add UNDO_HISTORY_LIMIT and PROPERTY_EDIT_DEBOUNCE_MS constants to crates/rpa-core/src/constants.rs\n\n## Problem\nUndo/redo system needs configurable constants for history size and property edit debouncing.\n\n## Instructions\n1. Open crates/rpa-core/src/constants.rs\n2. Add to UiConstants impl:\n   - pub const UNDO_HISTORY_LIMIT: usize = 100;\n   - pub const PROPERTY_EDIT_DEBOUNCE_MS: f32 = 500.0;\n\n## Suggested Implementation\nAdd after line 66 (after IR_COMPILATION_MAX_DEPTH):\n```rust\npub const UNDO_HISTORY_LIMIT: usize = 100;\npub const PROPERTY_EDIT_DEBOUNCE_MS: f32 = 500.0;\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-27T12:48:49.6625408+05:00","updated_at":"2025-12-27T12:53:41.793735+05:00","closed_at":"2025-12-27T12:53:41.793735+05:00","close_reason":"Closed"}
{"id":"rpa-so7","title":"Fix error pin positioning in vertical flow","description":"In vertical flow mode, error pins on nodes with error outputs are rendered at the bottom right area of the node instead of the center right edge. Fix by changing line 473 in crates/rpa-core/src/node_graph.rs from 'egui::vec2(pin_offset_right, self.height)' to 'egui::vec2(self.width, pin_offset_center)' in the error pin positioning logic for the vertical flow case.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-26T19:38:03.3438426+05:00","updated_at":"2025-12-26T19:39:40.6604863+05:00","closed_at":"2025-12-26T19:39:40.6604863+05:00","close_reason":"Closed"}
{"id":"rpa-sq2","title":"Replace map().unwrap_or() with map_or()","description":"Replace map().unwrap_or() with map_or() for better idiomaticity. Affects: execution.rs lines 398-404 where map(|n| n as i64).unwrap_or(*end) should use map_or(*end, |n| n as i64)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T16:00:04.5895129+05:00","updated_at":"2025-12-25T21:25:15.2264791+05:00","closed_at":"2025-12-25T21:25:15.2264791+05:00","close_reason":"Closed"}
{"id":"rpa-szp","title":"Add explicit compilation recursion depth limit","description":"PROBLEM:\nThere is no explicit recursion depth limit during IR compilation in compile_from_node() or compile_from_called_scenario(). While execution has a 100-call limit for CallScenario instructions (execution.rs line 532), compilation only has the implicit Rust stack limit. This can cause stack overflow during compilation of deeply nested scenarios.\n\nLocation: ir.rs (compile_from_node() and compile_from_called_scenario())\n\nSOLUTION:\nImplement explicit recursion depth tracking:\n1. Add compilation_depth counter field to IrBuilder struct\n2. Increment at start of compile_from_node() and compile_from_called_scenario()\n3. Decrement on return from both functions\n4. Check if compilation_depth \u003e= limit (suggest 1000 or match execution limit of 100)\n5. Return error if limit exceeded\n\nRecommended implementation:\n- Add: compilation_depth: usize field to IrBuilder\n- At start of compile_from_node(): check depth, increment\n- At start of compile_from_called_scenario(): check depth, increment\n- Use guard or pattern for automatic decrement (Rust RAII)\n- Set limit to reasonable value (100-1000 depending on performance)\n\nADDITIONAL INFO:\n- Execution has 100-call limit (execution.rs lines 532-533)\n- Compilation has no explicit limit (only stack limit)\n- Deep linear chains of nodes can overflow stack\n- Stack limit varies by system (typically 2-8MB)\n- Impact: Potential stack overflow on deeply nested scenarios\n- Severity: MEDIUM - edge case but catastrophic when hit\n- Dependency: Independent, can be fixed anytime\n- Should use consistent limit with execution (100) or higher\n- Consider adding informative error message with current depth","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-27T01:37:37.8760142+05:00","updated_at":"2025-12-27T11:56:52.7068863+05:00","closed_at":"2025-12-27T11:56:52.7068863+05:00","close_reason":"Closed"}
{"id":"rpa-ted","title":"Add TODO for save state history handling","description":"Add TODO comment for future decision on undo history behavior after save\n\n## Problem\nFuture release needs to decide: should undo history persist across file saves, or clear on save?\n\n## Instructions\n1. In the undo_redo.rs module or main.rs initialization\n2. Add TODO comment explaining decision needed:\n   - Option 1: Clear history on file save (cleaner UX, current recommendation)\n   - Option 2: Persist history to temporary state file (more powerful, uses disk space)\n   - Option 3: Keep history independent of save (current implementation)\n\n3. When file save is implemented, revisit this decision\n4. Add method: fn clear_undo_history() for future use\n\n## Suggested Implementation\nAdd near file save handler:\n// TODO: Decide undo history behavior on save\n// - Should we clear the undo history when user saves?\n// - Or persist it to a .state file alongside the .rpa project?","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-27T12:49:41.2144539+05:00","updated_at":"2025-12-27T13:21:23.0141711+05:00","closed_at":"2025-12-27T13:21:23.0141711+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-ted","depends_on_id":"rpa-9vh","type":"blocks","created_at":"2025-12-27T12:49:56.1156389+05:00","created_by":"daemon"}]}
{"id":"rpa-uu8","title":"Fix IfCondition: Add target address backpatching after branch compilation","description":"PROBLEM:\nThe IfCondition handler in compile_from_called_scenario() never backpatches the jump instruction targets after compiling branches. This leaves targets at 0, causing undefined behavior at execution time (likely jumping to program start or causing invalid jumps).\n\nLocation: ir.rs lines 790-807\n\nSOLUTION:\nAdd backpatching code after branch compilation to set correct jump targets:\n1. Calculate false_start position (instruction index where false branch begins)\n2. Calculate after_if position (instruction index where code continues after both branches)\n3. Patch the JumpIf (or JumpIfNot after fix) target to point to false_start\n4. Patch the Skip Jump target to point to after_if\n\nCopy the pattern from main scenario (lines 497-507):\n- Store instruction indices when adding Jump instructions\n- After all branch compilation, update the targets with correct addresses\n- Use mutable reference to program.instructions to modify targets\n\nADDITIONAL INFO:\n- This is part of asymmetric If node handling between main and nested scenarios\n- Main scenario (lines 497-507) correctly backpatches both jump targets\n- Nested scenario (lines 790-807) completely missing this\n- Target remaining at 0 causes jump to undefined location\n- Impact: Execution flow is undefined, likely crashes or loops\n- Severity: CRITICAL - causes undefined behavior at runtime\n- Dependency: This fix depends on rpa-c65, rpa-ay8, rpa-zuz being applied first\n- Must have correct targets calculated to patch correctly","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-27T01:37:06.4431557+05:00","updated_at":"2025-12-27T01:42:04.9426711+05:00","closed_at":"2025-12-27T01:42:04.9426711+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-uu8","depends_on_id":"rpa-zuz","type":"blocks","created_at":"2025-12-27T01:38:02.6124673+05:00","created_by":"daemon"}]}
{"id":"rpa-v12","title":"Fix unseparated literal suffixes (_u8 separators)","description":"Fix unseparated literal suffixes in crates/rpa-core/src/validation.rs. Replace 0u8, 1u8, 2u8, etc. with 0_u8, 1_u8, 2_u8 format. Affected lines: 932, 936, 940, 945, 953, 959, 963, 972, 979, 983, 987, 995, 1000, 1006-1012","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T16:02:56.0410844+05:00","updated_at":"2025-12-25T17:11:02.5105104+05:00","closed_at":"2025-12-25T17:11:02.5105104+05:00","close_reason":"Closed"}
{"id":"rpa-vtl","title":"Implement resize transaction grouping for nodes","description":"Group node resize operations so entire resize = one undo step (not per-frame)\n\n## Problem\nSimilar to drag operations, resizing notes frame-by-frame creates too many undo states.\n\n## Instructions\n1. Find node resize handling in ui.rs or canvas rendering\n2. When resize starts (mouse down on resize handle):\n   - Call: self.begin_undo_transaction()\n   - Store initial size\n\n3. During resize (mouse moving):\n   - Update size, DON'T snapshot\n   - Keep transaction_in_progress = true\n\n4. When resize ends (mouse up):\n   - Call: self.end_undo_transaction()\n   - Single snapshot of final size\n\n## Suggested Implementation\nReuse same transaction state as drag operations:\n- Check transaction_in_progress flag\n- Only snapshot on transaction end","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-27T12:49:20.6925351+05:00","updated_at":"2025-12-27T13:12:16.3268857+05:00","closed_at":"2025-12-27T13:12:16.3268857+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-vtl","depends_on_id":"rpa-455","type":"blocks","created_at":"2025-12-27T12:49:54.6971357+05:00","created_by":"daemon"}]}
{"id":"rpa-w53","title":"Fix uninlined format args throughout codebase","description":"Fix uninlined format args throughout codebase. Replace format!(\"{}\", var) with format!(\"{var}\"). Affects: activity_metadata.rs, evaluator.rs (lines 40, 50, 127, 284, 287, 496, 525), execution.rs (lines 170, 204, 230, 254, 278, 300, 305, 336, 341, 376, 465, 530, 566, 589, 650, 668, 704, 741)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T15:59:55.5000745+05:00","updated_at":"2025-12-25T17:15:19.3459117+05:00","closed_at":"2025-12-25T17:15:19.3459117+05:00","close_reason":"Closed"}
{"id":"rpa-xbd","title":"Fix else-if-without-else control flow patterns","description":"Fix else-if-without-else patterns by adding final else blocks: (1) ir.rs:221-224 - add else block after else if checking var_value, (2) validation.rs:370-380 - add else block after else if checking step \u003c 0","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T16:03:00.7495461+05:00","updated_at":"2025-12-25T16:13:06.9888746+05:00"}
{"id":"rpa-xsg","title":"Fix undo/redo buttons greyed out on app startup","description":"## Problem\nThe undo and redo buttons remain greyed out immediately after app startup, and Ctrl+Z/Ctrl+Y keyboard shortcuts do nothing. This occurs even after making changes to the workflow.\n\n## Root Cause\nThe UndoRedoManager initializes with an empty Undoer during RpaApp::default(). egui's Undoer requires an established baseline state to track history from. Without this initial snapshot:\n- has_undo() and has_redo() return false (no history to reference)\n- Subsequent snapshots on mutations can't establish proper undo/redo tracking\n- UI buttons and keyboard shortcuts remain non-functional\n\n## Solution\nImplement a with_initial_snapshot() builder method on RpaApp that:\n1. Takes ownership of self (from RpaApp::default())\n2. Calls snapshot_undo_state() to establish the baseline state\n3. Returns self with the undoer properly initialized\n\nThen update main() to use: RpaApp::default().with_initial_snapshot()\n\nThis ensures egui's Undoer has an established reference point before any mutations occur.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-27T13:26:34.6081425+05:00","updated_at":"2025-12-27T13:27:08.7774081+05:00","closed_at":"2025-12-27T13:27:08.7774081+05:00","close_reason":"Closed"}
{"id":"rpa-xsm","title":"Replace to_string with explicit clone where applicable","description":"Replace implicit_clone (to_string) with explicit clone. Affects: execution.rs line 268 where err.to_string() should be err.clone()","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T16:00:03.2758487+05:00","updated_at":"2025-12-25T16:11:50.6405398+05:00"}
{"id":"rpa-zuz","title":"Fix IfCondition: Add skip Jump instruction between branches","description":"PROBLEM:\nThe IfCondition handler in compile_from_called_scenario() is missing a Jump instruction to skip the false branch after the true branch executes. This causes both branches to execute sequentially regardless of condition.\n\nLocation: ir.rs lines 790-807\n\nSOLUTION:\nAdd a Jump instruction between true and false branches:\n1. After compiling true branch, save current instruction index\n2. Add Instruction::Jump with target: 0 (placeholder)\n3. Record false branch start position\n4. Compile false branch\n5. Later backpatch the Jump target to skip over false branch\n\nCopy the pattern from main scenario (lines 481-488):\n- Check if false_target exists\n- If yes, add Jump instruction before false branch\n- Record its index for later patching\n\nADDITIONAL INFO:\n- This is part of asymmetric If node handling between main and nested scenarios\n- Main scenario (lines 481-488) correctly adds skip Jump instruction\n- Nested scenario (lines 790-807) completely missing this\n- Without skip instruction, both branches execute\n- Impact: If condition has no effect on execution flow\n- Severity: CRITICAL - branches execute unconditionally\n- Dependency: Must be coordinated with other If fixes\n- The Jump target needs backpatching (see rpa-c66 for target patching)","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-27T01:37:00.4069209+05:00","updated_at":"2025-12-27T01:42:04.9400807+05:00","closed_at":"2025-12-27T01:42:04.9400807+05:00","close_reason":"Closed","dependencies":[{"issue_id":"rpa-zuz","depends_on_id":"rpa-ay8","type":"blocks","created_at":"2025-12-27T01:38:02.2866994+05:00","created_by":"daemon"}]}
